#pragma once

/// <summary>
/// A container for a (hopefully) unique long long data. 
/// </summary>
/// <remarks>
/// Generated by the system clock during construction. Does NOT check for uniqueness among existing amUuid objects.
/// </remarks>

#include <chrono>

#include "Clock.h"

class amUuid
{
public:
	bool operator==(const amUuid & rh) const
	{
		return data_ == rh.get_data();
	}

	bool operator!=(const amUuid & rh) const
	{
		return data_ != rh.get_data();
	}

	amUuid()
	{
		auto now = std::chrono::high_resolution_clock::now();
		auto nanoseconds = std::chrono::duration_cast<std::chrono::nanoseconds>(now.time_since_epoch());

		data_ = nanoseconds.count();
	}

	amUuid(long long uuid)
	{
		data_ = uuid;
	}

	long long get_data() const { return data_; }

	bool isNil() const { return data_ == 0; }
private:
	long long data_;

};

class amUuidHasher
{
public:
	size_t operator()(const amUuid & rh) const
	{
		return rh.get_data();
	}
};