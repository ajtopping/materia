#pragma once

/// <summary>
/// A container for a (hopefully) unique long long data. 
/// </summary>
/// <remarks>
/// Generated by the system clock during construction. Does NOT check for uniqueness among existing amUuid objects.
/// </remarks>

#include <chrono>

#include "Clock.h"
//#include "Uuid.hpp"

class amUuid
{
public:
	bool operator==(const amUuid & rh) const
	{
		return data_ == rh.get_data();
	}

	bool operator!=(const amUuid & rh) const
	{
		return data_ != rh.get_data();
	}

	amUuid()
	{
		data_ = generate_unique_data_();
	}

	amUuid(long long uuid)
	{
		data_ = uuid;
	}

	/*
	amUuid(amUuid const & ref)
	{
		this->data_ = generate_unique_data_();
	}

	void operator=(amUuid const & ref)
	{
		this->data_ = generate_unique_data_();
	}
	*/

	void clone_data(amUuid const & ref)
	{
		this->data_ = ref.get_data();
	}

	long long get_data() const { return data_; }

	bool isNil() const { return data_ == 0; }
private:
	long long data_;

	long long generate_unique_data_()
	{
		auto now = std::chrono::high_resolution_clock::now();
		auto nanoseconds = std::chrono::duration_cast<std::chrono::nanoseconds>(now.time_since_epoch());

		return nanoseconds.count();
	}

};

class amUuidHasher
{
public:
	size_t operator()(const amUuid & rh) const
	{
		return (size_t)rh.get_data();
	}
};